{"ast":null,"code":"import { ref, onMounted, onBeforeUnmount } from 'vue';\nexport default {\n  __name: 'onlineAlaysis',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const video = ref();\n    const mediaStreamTrack = ref({});\n    const canvas = ref();\n    const ctx = ref();\n    const socket = new WebSocket('ws://localhost:8888');\n    const dataChannel = ref();\n    const peerConnection = ref();\n    onMounted(() => {\n      console.log('正在打开摄像头。。。');\n      getCamera();\n      //连接后端socket\n      connection();\n      reconnection();\n    });\n    function connection() {\n      socket.onopen = () => {\n        console.log('socket 已打开...');\n      };\n    }\n    async function reconnection() {\n      console.log('Attempting to reconnect...');\n      setTimeout(connection(), 3000); // 3秒后尝试重新连接\n    }\n    function getCamera() {\n      canvas.value = document.getElementById('camera');\n      ctx.value = canvas.value.getContext('2d');\n      if (navigator.mediaDevices) {\n        navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: false\n        }).then(stream => {\n          video.value.srcObject = stream;\n          video.value.play();\n          mediaStreamTrack.value = stream.getTracks()[0];\n          //创建WebRTC通道\n          peerConnection.value = new RTCPeerConnection();\n          dataChannel.value = peerConnection.value.createDataChannel('videoChannel');\n          dataChannel.value.onopen = () => {\n            console.log('Data channel opened');\n            var chunkSize = 16000; // 每次发送的数据块大小\n            var sendBuffer = function (offset) {\n              let stream = video.value.srcObject;\n              var slice = stream.getVideoTracks()[0].slice(offset, offset + chunkSize);\n              var reader = new FileReader();\n              reader.onload = function (event) {\n                if (dataChannel.value.readyState === 'open') {\n                  dataChannel.value.send(event.target.result);\n                  if (offset + chunkSize < stream.getVideoTracks()[0].length) {\n                    sendBuffer(offset + chunkSize);\n                  }\n                }\n              };\n              reader.readAsArrayBuffer(slice);\n            };\n            sendBuffer(0); // 开始发送视频流\n          };\n        }).catch(err => {\n          console.log(err);\n        });\n      } else {\n        //防止浏览器版本旧不支持mediaDevices\n        navigator.mediaDevices = {};\n      }\n    }\n    onBeforeUnmount(() => {\n      closeCamera();\n    });\n    function closeCamera() {\n      let stream = video.value.srcObject;\n      if (!stream) return;\n      let tracks = stream.getTracks();\n      tracks.forEach(x => {\n        x.stop();\n      });\n    }\n    function getDetection() {\n      console.log(\"aaa\");\n      peerConnection.value.ondatachannel = event => {\n        dataChannel.value = event.channel;\n        dataChannel.value.onopen = () => {\n          console.log('Data channel opened');\n          var chunkSize = 16000; // 每次发送的数据块大小\n          var sendBuffer = function (offset) {\n            let stream = video.value.srcObject;\n            var slice = stream.getVideoTracks()[0].slice(offset, offset + chunkSize);\n            var reader = new FileReader();\n            reader.onload = function (event) {\n              if (dataChannel.value.readyState === 'open') {\n                dataChannel.value.send(event.target.result);\n                if (offset + chunkSize < stream.getVideoTracks()[0].length) {\n                  sendBuffer(offset + chunkSize);\n                }\n              }\n            };\n            reader.readAsArrayBuffer(slice);\n          };\n          sendBuffer(0); // 开始发送视频流\n        };\n      };\n    }\n    function closeDetection() {\n      dataChannel.value.close();\n    }\n    const __returned__ = {\n      video,\n      mediaStreamTrack,\n      canvas,\n      ctx,\n      socket,\n      dataChannel,\n      peerConnection,\n      connection,\n      reconnection,\n      getCamera,\n      closeCamera,\n      getDetection,\n      closeDetection,\n      ref,\n      onMounted,\n      onBeforeUnmount\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","onMounted","onBeforeUnmount","video","mediaStreamTrack","canvas","ctx","socket","WebSocket","dataChannel","peerConnection","console","log","getCamera","connection","reconnection","onopen","setTimeout","value","document","getElementById","getContext","navigator","mediaDevices","getUserMedia","audio","then","stream","srcObject","play","getTracks","RTCPeerConnection","createDataChannel","chunkSize","sendBuffer","offset","slice","getVideoTracks","reader","FileReader","onload","event","readyState","send","target","result","length","readAsArrayBuffer","catch","err","closeCamera","tracks","forEach","x","stop","getDetection","ondatachannel","channel","closeDetection","close"],"sources":["C:/Users/31136/Desktop/face_anti_front/src/components/onlineAlaysis.vue"],"sourcesContent":["<template>\r\n <div class=\"container\">\r\n    <video src=\"\" ref=\"video\" id=\"video\"></video>\r\n    <canvas id=\"camera\"></canvas>\r\n    <div class=\"botton_box\">\r\n        <el-button type=\"primary\" @click=\"getCamera()\">打开摄像头</el-button>\r\n        <el-button type=\"danger\" @click=\"closeCamera()\">关闭摄像头</el-button>\r\n        <el-button type=\"primary\" @click=\"getDetection()\">开始检测</el-button>\r\n        <el-button type=\"danger\" @click=\"closeDetection()\">关闭检测</el-button>\r\n        <el-button type=\"primary\" @click=\"function(){}\">保存截图</el-button>\r\n        \r\n    </div>\r\n    \r\n </div>\r\n</template>\r\n\r\n<script setup>\r\nimport {ref,onMounted,onBeforeUnmount,} from 'vue';\r\nconst video = ref()\r\nconst mediaStreamTrack = ref({})\r\nconst canvas = ref()\r\nconst ctx = ref()\r\nconst socket = new WebSocket('ws://localhost:8888');\r\nconst dataChannel  = ref()\r\nconst peerConnection = ref()\r\nonMounted(()=>{\r\n    console.log('正在打开摄像头。。。')\r\n    getCamera();\r\n    //连接后端socket\r\n    connection()\r\n    reconnection()\r\n})\r\nfunction connection(){\r\n    socket.onopen = ()=>{\r\n        console.log('socket 已打开...')\r\n    }\r\n}\r\nasync function reconnection(){\r\n    console.log('Attempting to reconnect...');\r\n    setTimeout(connection(), 3000); // 3秒后尝试重新连接\r\n}\r\nfunction getCamera(){\r\n    canvas.value = document.getElementById('camera');\r\n    ctx.value = canvas.value.getContext('2d');\r\n    if(navigator.mediaDevices){\r\n        navigator.mediaDevices.getUserMedia({video:true,audio:false}).then((stream)=>{\r\n            video.value.srcObject = stream;\r\n            video.value.play();\r\n            mediaStreamTrack.value = stream.getTracks()[0];\r\n            //创建WebRTC通道\r\n            peerConnection.value = new RTCPeerConnection()\r\n            dataChannel.value = peerConnection.value.createDataChannel('videoChannel')\r\n            dataChannel.value.onopen = ()=>{\r\n            console.log('Data channel opened');\r\n            var chunkSize = 16000; // 每次发送的数据块大小\r\n            var sendBuffer = function(offset) {\r\n                let stream = video.value.srcObject\r\n                var slice = stream.getVideoTracks()[0].slice(offset, offset + chunkSize);\r\n                var reader = new FileReader();\r\n                reader.onload = function(event) {\r\n                    if (dataChannel.value.readyState === 'open') {\r\n                        dataChannel.value.send(event.target.result);\r\n                        if (offset + chunkSize < stream.getVideoTracks()[0].length) {\r\n                            sendBuffer(offset + chunkSize);\r\n                        }\r\n                    }\r\n                };\r\n                reader.readAsArrayBuffer(slice);\r\n            };\r\n\r\n            sendBuffer(0); // 开始发送视频流\r\n        };\r\n        }).catch((err)=>{\r\n            console.log(err)\r\n        })\r\n    }else{\r\n        //防止浏览器版本旧不支持mediaDevices\r\n        navigator.mediaDevices={}\r\n    }\r\n}\r\nonBeforeUnmount(()=>{\r\n    closeCamera();\r\n})\r\nfunction closeCamera(){\r\n    let stream = video.value.srcObject;\r\n    if (!stream) return;\r\n    let tracks = stream.getTracks();\r\n    tracks.forEach((x) => {\r\n    x.stop();\r\n    });\r\n}\r\nfunction getDetection(){\r\n    console.log(\"aaa\")\r\n    peerConnection.value.ondatachannel  = (event)=>{\r\n        dataChannel.value = event.channel;\r\n        dataChannel.value.onopen = ()=>{\r\n            console.log('Data channel opened');\r\n            var chunkSize = 16000; // 每次发送的数据块大小\r\n            var sendBuffer = function(offset) {\r\n                let stream = video.value.srcObject\r\n                var slice = stream.getVideoTracks()[0].slice(offset, offset + chunkSize);\r\n                var reader = new FileReader();\r\n                reader.onload = function(event) {\r\n                    if (dataChannel.value.readyState === 'open') {\r\n                        dataChannel.value.send(event.target.result);\r\n                        if (offset + chunkSize < stream.getVideoTracks()[0].length) {\r\n                            sendBuffer(offset + chunkSize);\r\n                        }\r\n                    }\r\n                };\r\n                reader.readAsArrayBuffer(slice);\r\n            };\r\n\r\n            sendBuffer(0); // 开始发送视频流\r\n        };\r\n    }\r\n    \r\n}\r\n\r\nfunction closeDetection(){\r\n    dataChannel.value.close();\r\n}\r\n\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.container{\r\n    display: flex;\r\n    width: 84vw;\r\n    max-height: 90vh;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    background-color: #f0f0f0;\r\n    padding-top: 1%;\r\n    padding-bottom: 3%;\r\n}\r\n#camera{\r\n    width:0;\r\n    height:0;\r\n    display: none;\r\n}\r\n#video{\r\n    width:60vw;\r\n}\r\n.botton_box{\r\n    margin-top: 10px;\r\n    display: flex;\r\n    flex-direction: row;\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}